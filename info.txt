


-----------------------------

npm init -y
npm i typescript -g
npx tsc --init  //tsconfig.json 파일생성
tsc source.ts


ts-node index.ts

-----------------------------

섹션 1: Getting Started
1. Course Introduction
2. RxJS Overview

-----------------------------

3. Quick Start

-----------------------------

4. Optional: Using your own IDE


-----------------------------

5. Course Plan

+ Observables
+ Subscriptions
+ Observers
+ Creation Functions
+ Pipeable Operators
+ Subjects

-----------------------------

6. Learning Tips

-----------------------------

섹션 2: Observable - how does it work?

-----------------------------

7. Module Introduction

+ Stream
+ Observable
+ Subscription
+ Observer
+ Marble Diagrams
+ Notification Types

-----------------------------

8. Array vs Stream

What is a stream?

-----------------------------

9. Observable, Subscription, Observer - Key Elements

Observable 
  + 일련의 규칙이 있는 단일 콜백 함수를 기반으로 한다.
  + 실행 되면 알림을 보낼 수 있다.
  + 세가지 유형이 있다.
    + 다음 알림
    + 오류
    + 완료

+ Observable 
const observable$ = new Observable(subscriber => {
    subscriber.next("Alice");
    subscriber.next("Ben");
})

+ Observer
const observer = {
    next: value => console.log(value)
}
// Observer의 next함수는 Observable이 내보낸 다음 알림에 대한 동작을 제공

// Observable 자체는 코드를 실행하지 않는다.
// Observable은 내부에 콜백 함수가 저장된 스페셜 객체
// Observer는 방출된 값에 대한 반응을 설명

+ Subscription
observable$.subscribe(observer);

// 각 Observable은 subscribe 메서드를 노출, 새 구독을 새작하려면 subscribe를 호출하기만 하면 된다.
// Observable의 메서드를 사용하고 Observer를 인수로 전달할 수 있다.

// 실행단계
    Observable에서 subscribe 메서드가 호출. 
    이 시점에서 새 구독이 만들어 진다.
    즉, Observable의 콜백이 다음과 함께 실행된다.
    제공된 Observer는 구독자 개체로 변환된다.
    이 시점에서 알아야 할 중요한 것은 
    가입자가 다음 메소드를 사용할 때마다 다음 값이 방출되고 실
    제로 Observer의 다음 핸들러는 방출된 값으로 호출



-----------------------------

10. Warm-up Observable - Observable, Observer, Subscription

+ 구독의 종료
  + Observable의 논리 자체에 의해 오류를 내보냄.
  + 알림을 완료하여 자동으로 닫힘
  + 구독을 취소하여 직접 구독을 취소 -> 더 이상 데이터를 수신하고 싶지 않다는것을 의미

Subscription 객체에서 subscribe()를 호출해 구독을 취소
Subscription 객체에 대한 참조를 얻는 방법
Observable에서 subscribe를 호출하면 Subscription 객체가 반환

-----------------------------

11. Warm-up Observable - Multiple Subscriptions

Observable에 대한 각각의 새로운 구독이 다른 구독과는 독립적이다.
따라서 구독은 인수로 전달된 Observer 객체를 사용하여 일반 함수를 실행하는 것과 같다.

-----------------------------

12. Marbles Introduction

-----------------------------

13. Marbles - Next, Error, Complete

-----------------------------

14. Marbles - Notification Types Summary

-----------------------------

15. Marbles - Incorrect Scenarios

-----------------------------

16. Marbles - Appearance

-----------------------------

17. Marbles - Game

-----------------------------

18. Marbles - Docs

-----------------------------

19. Module Summary

-----------------------------

섹션 3: Exercises: Observable, Observer and Subscription

-----------------------------

20. Module Introduction

-----------------------------

21. Subscription Lifecycle

-----------------------------

22. Execution Timing - Empty Observable

-----------------------------

23. Synchronous Emission - Next Notification

-----------------------------

24. Asynchronous Emission - More Next Notifications

-----------------------------

25. Teardown - Complete Notification

-----------------------------

26. Error Notification

-----------------------------

27. Full Observer

-----------------------------

28. Order

-----------------------------

29. Cancellation - Unsubscribe

-----------------------------

30. Module Summary

-----------------------------

섹션 4: Types of Observable

-----------------------------

31. Module Introduction

-----------------------------

32. Cold Observable

random-data-api.com
https://random-data-api.com/api/name/random_name

tsc 32-index.ts

rxjs-playground.zip

-----------------------------

33. Hot Observable

-----------------------------

34. Hot vs Cold - Comparison

+ Cold
  Produces the data inside

  New subscriber
    - new data

  Set of values
  HTTP Request
  Timer/Interval

+ Hot
  Multicasts the data from a common source

  All subscribers
    - common data

  DOM Events
  State
  Subjects

-----------------------------

35. Module Summary

Cold Observables - 구독할때마다 배출 소스를 생성
Hot Observables - 이미 존재하는 소스를 사용. 각 활성 구독에 데이터를 멀티캐스트

-----------------------------

섹션 5: Creation Functions

-----------------------------

36. Module Introduction

+ of - 인수로 제공된 값을 내보내고 완료
+ from - 배열, Promise, Iterable같은 것을 Observable로 변환
+ fromEvent - 일부 이벤트 대상에서 Observable을 생성
  + subscribe - addEventListener
  + unsubscribe - removeEventListener
+ interval/timer - 약간의 지연또는 간격이 있는 알림을 내보내는 Observable을 생성
  - setTimeout, setInterval과 같은 역할
+ forkJoin - Observable 배열을 입력으로 받아들인다.
  - 이 모든 Observable이 완료되면 각각에 의해 방출된 최신 값의 집합이 된다.
  - 몇 번의 HTTP 호출 결과를 기다려야 하는 경우에 매우 유용.
+ combineLatest - 여러 입력 Observable도 허용
  - 그들 중 하나가 새로운 것을 방출 할 때마다 최신 값의 결합된 세트가 배열로 방출

-----------------------------

37. of - How Creation Functions work

- of 함수를 사용하여 생성된 Observable은 여러 반환 값을 가진 함수처럼 작동
- 따라서 subscribe 메서드를 호출할 때 제공된 모든 값을 즉시 내보낸 다음 완료
- 시도한 후 'new Observable' 생성자를 사용하여 동일한 동작을 다시 생성한다.
- 마지막으로 of 생성 기능을 다시 만들어 본다.

-----------------------------

38. from

- 다른 유형을 Observable로 변환하는데 사용
- from([A,B,C]) -> of 생성함수와 같은 방식으로 작동
  - 여러 인수를 제공하는 대신 값이 포함된 배열을 제공
- Promise에서 Observable을 만드는 것
  - from(Promise)
  - Observable을 구독하면, Promise의 resolve 값을 다음 알림으로 내보내지고 완료.
  - Promise가 거부되면 Observable은 오류 알림을 내보낸다.
- iterable(생성기 함수) 및 기타 Observable과 같은 다른 소스에서 Observable을 생성
  - from(...)

-----------------------------

39. fromEvent

- DOM EventTarget, Node.js EventEmitter, jQuery Events를 포함한 여러 이벤트 대상을 지원
- 사용자가 버튼을 클릭할 때마다 이벤트를 내보내는 Observable을 만드는 데 유용

fromEvent(button, 'click')

subscribe()   <---> addEventListener()
unsubscribe() <---> removeEventListener()

- fromEvent로 만든 Observable은 절대 완료되지 않으므로 수신을 중지하려면 구독을 취소
- fromEvent는 Hot Observable을 만든다.
  -> 데이터의 실제 생산자인 실제 소스가 Observable외부에 있기 때문

-----------------------------

40. timer

-----------------------------

41. interval

-----------------------------

42. forkJoin - Handle multiple HTTP calls

- 다른 Observable을 입력으로 소스로 받아들인다.
- Observable 배열을 전달할 수 있다.
- 구독하면 제공된 모든 입력 Observable에 대한 구독이 생성
- 그런 다음 모든 Observable이 완료될 때까지 기다린다.
- 그리고 일단 이런 일이 발생하면 모든 값에서 최신 값 세트를 내보낸다.
- 동시에 여러 HTTP 엔트 포인트를 호출하고 모든 엔드포인트를 기다리는 경우에 유용
-----------------------------

43. forkJoin - Error Scenario

-----------------------------

44. combineLatest - Reacting to multiple input changes

- 최신값으로 배열을 방출
- 여러개의 입력이 모두 값을 방출하면, 최신 값을 방출하기 시작
- 각 입력이 값을 방출할 때마다, 그때의 값을 방출

A                     ---A------------------B------------------------C--------|-
B                     -----------1---------------------2-------|----------------
combineLatest([A,B])  ---------[A,1]-------[B,1]------[B,2]---------[C,2]-----|-

Error

A                     ---A------------------B-------------------
B                     -----------1---------------------2-------X--
combineLatest([A,B])  ---------[A,1]-------[B,1]------[B,2]----X--

-----------------------------

45. Module Summary

-----------------------------

섹션 6: Pipeable Operators

- Observable에서 내보내는 알림을 수많은 방법으로 변환할 수 있게 해주는 RxJS의 가장 강력한 기능 중 하나
- 방출된 값을 필터링 및 매핑하고, 
- 오류 시나리오에 대한 대체를 제공하거나, 
- 다른 Observable에 대한 새 내부 구독을 시작

- 몇 줄의 코드로 복잡한 비동기 논리를 작성할 수 있으므로 읽기 쉽고 작업하기 쉽다.

-----------------------------

46. Module Introduction

+ filter : '필터' 파이프 가능한 연산자가 방출된 값을 필터링하고 통과 여부를 전달
+ map : 방출된 값을 가져와 다른 값으로 변환
        더 복잡한 개체 내부에 중첩된 일부 단일 속성을 추출하는 데 매우 유용
+ tab : 알림을 변경하지 않고 부작용을 일으킬 수 있다.
        디버깅 및 학습 목적에 유용
        예) 여러 연산자를 스택에 사용하는 경우 연산자 파이프라인의 모든 단계에서 방출된 값을 콘솔에 기록
+ debounceTime : Observable 소스가 많은 값을 내보낸 다음 안정되는 경우에 유용
        종종 사용자의 입력과 함께 사용
        예) 사용자가 입력 필드에 일부 값을 입력하고 각 키 입력에 의해 트리거되는 재계산에 시간이 걸리고 느린 시나리오. 입력에서 오는 이벤트를 디바운스하고 사용자가 속도 저하 없이 값을 입력. 그런 다음 사용자가 입력을 중지한 후 재계산 코드가 한 번만 트리거

Pipeable Operators는 완전히 새로운 Observable을 출력
+ catchError : 소스 Observable에서 오류 알림이 발생하면 이 연산자는 이 오류를 전달하지 않고 대신 제공된 대체 Observable을 새 소스로 사용

+ Flattening Operators
  - concatMap
  - switchMap
  - mergeMap
  - exhaustMap
  들어오는 방출 값을 가져와 다른 Observable에 매핑
  어떤 것을 선택해야 할지 잘 모르겠다면 'concatMap' 변형이 가장 안전한 선택


-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------

47. Operator Stacking
48. filter
49. map
50. tap
51. Learn More: tap
52. debounceTime
53. catchError
퀴즈 8: Pipeable Operators
54. Flattening Operators
55. Flattening Operators - Static Example
56. Flattening Operators - Dynamic HTTP Request
57. Flattening Operators - Error Handling - First Solution
58. Flattening Operators - Error Handling - Second Solution
59. Flattening Operators - Concurrency - concatMap
60. Flattening Operators - switchMap
61. Flattening Operators - mergeMap
62. Flattening Operators - Side by Side Comparison
퀴즈 9: Pipeable Operators - Flattening Operators
63. Module Summary
섹션 7: Subjects
64. Module Introduction
65. Multicasting
66. Subject vs Observable vs Observer
67. Subject in Action
68. BehaviorSubject - Concept
69. BehaviorSubject in Action
70. Module Summary
퀴즈 10: Subjects
섹션 8: Course Summary
71. Course Summary
72. Congratulations &amp; Further Steps
