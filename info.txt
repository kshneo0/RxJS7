


-----------------------------

npm init -y
npm i typescript -g
npx tsc --init  //tsconfig.json 파일생성
tsc source.ts


ts-node index.ts

-----------------------------

섹션 1: Getting Started
1. Course Introduction
2. RxJS Overview

-----------------------------

3. Quick Start

-----------------------------

4. Optional: Using your own IDE


-----------------------------

5. Course Plan

+ Observables
+ Subscriptions
+ Observers
+ Creation Functions
+ Pipeable Operators
+ Subjects

-----------------------------

6. Learning Tips

-----------------------------

섹션 2: Observable - how does it work?

-----------------------------

7. Module Introduction

+ Stream
+ Observable
+ Subscription
+ Observer
+ Marble Diagrams
+ Notification Types

-----------------------------

8. Array vs Stream

What is a stream?

-----------------------------

9. Observable, Subscription, Observer - Key Elements

Observable 
  + 일련의 규칙이 있는 단일 콜백 함수를 기반으로 한다.
  + 실행 되면 알림을 보낼 수 있다.
  + 세가지 유형이 있다.
    + 다음 알림
    + 오류
    + 완료

+ Observable 
const observable$ = new Observable(subscriber => {
    subscriber.next("Alice");
    subscriber.next("Ben");
})

+ Observer
const observer = {
    next: value => console.log(value)
}
// Observer의 next함수는 Observable이 내보낸 다음 알림에 대한 동작을 제공

// Observable 자체는 코드를 실행하지 않는다.
// Observable은 내부에 콜백 함수가 저장된 스페셜 객체
// Observer는 방출된 값에 대한 반응을 설명

+ Subscription
observable$.subscribe(observer);

// 각 Observable은 subscribe 메서드를 노출, 새 구독을 새작하려면 subscribe를 호출하기만 하면 된다.
// Observable의 메서드를 사용하고 Observer를 인수로 전달할 수 있다.

// 실행단계
    Observable에서 subscribe 메서드가 호출. 
    이 시점에서 새 구독이 만들어 진다.
    즉, Observable의 콜백이 다음과 함께 실행된다.
    제공된 Observer는 구독자 개체로 변환된다.
    이 시점에서 알아야 할 중요한 것은 
    가입자가 다음 메소드를 사용할 때마다 다음 값이 방출되고 실
    제로 Observer의 다음 핸들러는 방출된 값으로 호출



-----------------------------

10. Warm-up Observable - Observable, Observer, Subscription

+ 구독의 종료
  + Observable의 논리 자체에 의해 오류를 내보냄.
  + 알림을 완료하여 자동으로 닫힘
  + 구독을 취소하여 직접 구독을 취소 -> 더 이상 데이터를 수신하고 싶지 않다는것을 의미

Subscription 객체에서 subscribe()를 호출해 구독을 취소
Subscription 객체에 대한 참조를 얻는 방법
Observable에서 subscribe를 호출하면 Subscription 객체가 반환

-----------------------------

11. Warm-up Observable - Multiple Subscriptions

Observable에 대한 각각의 새로운 구독이 다른 구독과는 독립적이다.
따라서 구독은 인수로 전달된 Observer 객체를 사용하여 일반 함수를 실행하는 것과 같다.

-----------------------------

12. Marbles Introduction

-----------------------------

13. Marbles - Next, Error, Complete

-----------------------------

14. Marbles - Notification Types Summary

-----------------------------

15. Marbles - Incorrect Scenarios

-----------------------------

16. Marbles - Appearance

-----------------------------

17. Marbles - Game

-----------------------------

18. Marbles - Docs

-----------------------------

19. Module Summary

-----------------------------

섹션 3: Exercises: Observable, Observer and Subscription

-----------------------------

20. Module Introduction

-----------------------------

21. Subscription Lifecycle

-----------------------------

22. Execution Timing - Empty Observable

-----------------------------

23. Synchronous Emission - Next Notification

-----------------------------

24. Asynchronous Emission - More Next Notifications

-----------------------------

25. Teardown - Complete Notification

-----------------------------

26. Error Notification

-----------------------------

27. Full Observer

-----------------------------

28. Order

-----------------------------

29. Cancellation - Unsubscribe

-----------------------------

30. Module Summary

-----------------------------

섹션 4: Types of Observable

-----------------------------

31. Module Introduction

-----------------------------

32. Cold Observable

random-data-api.com
https://random-data-api.com/api/name/random_name

tsc 32-index.ts

rxjs-playground.zip

-----------------------------

33. Hot Observable

-----------------------------

34. Hot vs Cold - Comparison

+ Cold
  Produces the data inside

  New subscriber
    - new data

  Set of values
  HTTP Request
  Timer/Interval

+ Hot
  Multicasts the data from a common source

  All subscribers
    - common data

  DOM Events
  State
  Subjects

-----------------------------

35. Module Summary

Cold Observables - 구독할때마다 배출 소스를 생성
Hot Observables - 이미 존재하는 소스를 사용. 각 활성 구독에 데이터를 멀티캐스트

-----------------------------

섹션 5: Creation Functions

-----------------------------

36. Module Introduction

+ of - 인수로 제공된 값을 내보내고 완료
+ from - 배열, Promise, Iterable같은 것을 Observable로 변환
+ fromEvent - 일부 이벤트 대상에서 Observable을 생성
  + subscribe - addEventListener
  + unsubscribe - removeEventListener
+ interval/timer - 약간의 지연또는 간격이 있는 알림을 내보내는 Observable을 생성
  - setTimeout, setInterval과 같은 역할
+ forkJoin - Observable 배열을 입력으로 받아들인다.
  - 이 모든 Observable이 완료되면 각각에 의해 방출된 최신 값의 집합이 된다.
  - 몇 번의 HTTP 호출 결과를 기다려야 하는 경우에 매우 유용.
+ combineLatest - 여러 입력 Observable도 허용
  - 그들 중 하나가 새로운 것을 방출 할 때마다 최신 값의 결합된 세트가 배열로 방출

-----------------------------

37. of - How Creation Functions work

- of 함수를 사용하여 생성된 Observable은 여러 반환 값을 가진 함수처럼 작동
- 따라서 subscribe 메서드를 호출할 때 제공된 모든 값을 즉시 내보낸 다음 완료
- 시도한 후 'new Observable' 생성자를 사용하여 동일한 동작을 다시 생성한다.
- 마지막으로 of 생성 기능을 다시 만들어 본다.

-----------------------------

38. from

- 다른 유형을 Observable로 변환하는데 사용
- from([A,B,C]) -> of 생성함수와 같은 방식으로 작동
  - 여러 인수를 제공하는 대신 값이 포함된 배열을 제공
- Promise에서 Observable을 만드는 것
  - from(Promise)
  - Observable을 구독하면, Promise의 resolve 값을 다음 알림으로 내보내지고 완료.
  - Promise가 거부되면 Observable은 오류 알림을 내보낸다.
- iterable(생성기 함수) 및 기타 Observable과 같은 다른 소스에서 Observable을 생성
  - from(...)

-----------------------------

39. fromEvent

- DOM EventTarget, Node.js EventEmitter, jQuery Events를 포함한 여러 이벤트 대상을 지원
- 사용자가 버튼을 클릭할 때마다 이벤트를 내보내는 Observable을 만드는 데 유용

fromEvent(button, 'click')

subscribe()   <---> addEventListener()
unsubscribe() <---> removeEventListener()

- fromEvent로 만든 Observable은 절대 완료되지 않으므로 수신을 중지하려면 구독을 취소
- fromEvent는 Hot Observable을 만든다.
  -> 데이터의 실제 생산자인 실제 소스가 Observable외부에 있기 때문

-----------------------------

40. timer

-----------------------------

41. interval

-----------------------------

42. forkJoin - Handle multiple HTTP calls

- 다른 Observable을 입력으로 소스로 받아들인다.
- Observable 배열을 전달할 수 있다.
- 구독하면 제공된 모든 입력 Observable에 대한 구독이 생성
- 그런 다음 모든 Observable이 완료될 때까지 기다린다.
- 그리고 일단 이런 일이 발생하면 모든 값에서 최신 값 세트를 내보낸다.
- 동시에 여러 HTTP 엔트 포인트를 호출하고 모든 엔드포인트를 기다리는 경우에 유용
-----------------------------

43. forkJoin - Error Scenario

-----------------------------

44. combineLatest - Reacting to multiple input changes

- 최신값으로 배열을 방출
- 여러개의 입력이 모두 값을 방출하면, 최신 값을 방출하기 시작
- 각 입력이 값을 방출할 때마다, 그때의 값을 방출

A                     ---A------------------B------------------------C--------|-
B                     -----------1---------------------2-------|----------------
combineLatest([A,B])  ---------[A,1]-------[B,1]------[B,2]---------[C,2]-----|-

Error

A                     ---A------------------B-------------------
B                     -----------1---------------------2-------X--
combineLatest([A,B])  ---------[A,1]-------[B,1]------[B,2]----X--

-----------------------------

45. Module Summary

-----------------------------

섹션 6: Pipeable Operators

- Observable에서 내보내는 알림을 수많은 방법으로 변환할 수 있게 해주는 RxJS의 가장 강력한 기능 중 하나
- 방출된 값을 필터링 및 매핑하고, 
- 오류 시나리오에 대한 대체를 제공하거나, 
- 다른 Observable에 대한 새 내부 구독을 시작

- 몇 줄의 코드로 복잡한 비동기 논리를 작성할 수 있으므로 읽기 쉽고 작업하기 쉽다.

-----------------------------

46. Module Introduction

+ filter : '필터' 파이프 가능한 연산자가 방출된 값을 필터링하고 통과 여부를 전달
+ map : 방출된 값을 가져와 다른 값으로 변환
        더 복잡한 개체 내부에 중첩된 일부 단일 속성을 추출하는 데 매우 유용
+ tab : 알림을 변경하지 않고 부작용을 일으킬 수 있다.
        디버깅 및 학습 목적에 유용
        예) 여러 연산자를 스택에 사용하는 경우 연산자 파이프라인의 모든 단계에서 방출된 값을 콘솔에 기록
+ debounceTime : Observable 소스가 많은 값을 내보낸 다음 안정되는 경우에 유용
        종종 사용자의 입력과 함께 사용
        예) 사용자가 입력 필드에 일부 값을 입력하고 각 키 입력에 의해 트리거되는 재계산에 시간이 걸리고 느린 시나리오. 입력에서 오는 이벤트를 디바운스하고 사용자가 속도 저하 없이 값을 입력. 그런 다음 사용자가 입력을 중지한 후 재계산 코드가 한 번만 트리거

Pipeable Operators는 완전히 새로운 Observable을 출력
+ catchError : 소스 Observable에서 오류 알림이 발생하면 이 연산자는 이 오류를 전달하지 않고 대신 제공된 대체 Observable을 새 소스로 사용

+ Flattening Operators
  - concatMap
  - switchMap
  - mergeMap
  - exhaustMap
  들어오는 방출 값을 가져와 다른 Observable에 매핑
  어떤 것을 선택해야 할지 잘 모르겠다면 'concatMap' 변형이 가장 안전한 선택

-----------------------------

47. Operator Stacking


 SOURCE
   |
OBSERVER

- 구독할 수 있는 Observable 소스가 있고 
- 이 Observable 내부의 로직은 Observer에 도달할 다양한 알림을 내보낼 수 있습니다.

- 소스 Observable과 Observer 사이에 Pipeable Operator를 추가하고 싶다고 가정
- 연산자는 Observable을 입력으로 사용
- Observable이 소스이며 새로 만들어진 Observable을 반환
- 원래 소스 Observable을 변경하는 대신 연산자는 이 연산자가 도입한 논리로 확장된 새 소스를 만든다.

--------
 SOURCE
   |
OPERATOR
--------
   |
OBSERVER

- Observable 소스와 연산자의 이러한 조합을 구독할 때 어떤 일이 일어날지 생각
- Observable을 구독하면 연산자의 논리가 먼저 실행되고 소스 Observable을 구독하게 되어 사실상 논리를 실행하고 알림을 보내기 시작
- Observable이 무언가를 방출할 때마다 이 알림은 Observer에 도달하기 전에 먼저 운영자의 논리에 도달
- 따라서 운영자의 논리는 이 알림이 관찰자에게 도달할지 여부를 결정합니다.
- 또한 방출된 알림을 원하는 방식으로 변경하거나 자체 방출을 생성할 수도 있습니다.
- Observable 소스에서 내보낸 각 알림은 해당 알림으로 무엇을 할 것인지 결정하는 운영자에 의해 변환

--------
 SOURCE
   |
OPERATOR1
   |
OPERATOR2
   |
OPERATOR3
--------
   |
OBSERVER

- 각 연산자는 파이프라인에서 위쪽 부분인 입력 Observable을 수락하고 파이프라인에서 아래의 구독 또는 연산자가 사용하는 출력 Observable을 반환
- Observable을 구독하면 
  - 'Operator 3'은 먼저 'Operator 2'를 구독하는 코드를 실행
  - 그 다음 'Operator 1'을 구독
  - 마침내 맨 위에 있는 실제 배출원을 구독
  - 이 시점에서 Observable 소스가 무언가를 내보내면 이 알림이 먼저 'Operator 1'에 도달한 다음 결과가 'Operator 2'에 전달되는 식으로 진행됩니다.
  - 마지막으로 알림이 Observer에 도달
- Pipeable Operators를 사용하면 알림이 Observer에 도달하기 전에 알림을 변환
- 한 연산자의 출력이 다른 연산자의 입력이 될 수 있기 때문에 원하는 만큼 연산자를 적용
-----------------------------

48. filter

- 값이 소스에서 보내지면 이 연산자는 우리가 제공하는 조건에 따라 값을 출력으로 전달.
- 오류에 관심이 없고 완료.
-----------------------------

49. map

-오류에 관심이 없고 완료.

-----------------------------

50. tap

- 스파이처럼 작동하며 상호작용하지 않고 일부 부작용을 일으킬 수 있다.
- 여러 연산자가 쌓여 있고 알림을 관찰할 수 있기를 원하는 경우에 유용
- 예를 들어 콘솔에서 피드백을 받기 위해 무언가를 기록
- 어떤 식으로든 알림에 영향을 미치지 않는다.

- 각 알림에 대한 몇가지 부작용을 실행

-----------------------------

51. Learn More: tap

-----------------------------

52. debounceTime

- 시간 차원을 도입
- 들어오는 값을 디바운싱
- 디바운스 시간으로 2초를 제공하고 소스 Observable은 빠르게 세 값을 방출합니다.
- 'debounceTime' 연산자는 방출이 안정될 때까지 기다렸다가 2초 동안 새로운 방출이 없으면 가장 최근 값만 다시 방출
- 이는 성능 문제를 피하기 위해 또는 예를 들어 서버로 전송되는 HTTP 요청 빈도를 줄이기 위해 일부 재계산 논리에 과도한 압력을 가하는 것을 방지하는 데 유용
- 오류 및 완료 알림은 지연되지 않으며 변경되지 않은 형태로 즉시 전달
-----------------------------

53. catchError

- 원본 소스가 실패할 경우 대체 소스를 제공하는 데 사용
- 이 연산자는 방출된 값을 변경하지 않고 알림을 완료
- 변경되지 않은 형태로 전달
- 이 연산자는 오류 알림에만 관심
- 'catchError'를 사용하면 원래 소스에서 오류가 발생하는 경우에 사용할 대체 Observable을 제공
- 그런 일이 발생하면 catchError의 논리는 해당 오류를 재발송하지 않고 대신 제공된 대체 Observable을 구독
- 그리고 이 새로운 내부 구독에서 수신한 모든 알림은 출력으로 전달
-----------------------------

54. Flattening Operators

- 오류가 발생했을 때 제공된 Observable을 구독한 'catchError'처럼 작동
- Flattening Operators는 이와 같은 작업을 수행하지만 방출된 각 값을 다음으로 전달한다
- 사용자가 입력 값을 변경할 때마다 서버를 쿼리하려는 경우에 유용
- RxJS에는 concatMap, switchMap, mergeMap,exhaustMap과 같은 몇 가지 병합 연산자
- 어떤 것을 선택해야 할지 확실하지 않은 경우 가장 안전한 선택인 'concatMap' 변형에 중점

- Flattening Operators는 소스에서 수신한 다음 알림을 기반으로 생성된 제공된 Observable에 대한 새로운 내부 구독을 생성
- 그런 다음 해당 내부 구독에서 내보낸 값을 출력으로 전달합니다.

- 즉, Flattening Operator는 제공된 Observable에 대한 새로운 내부 구독을 생성하여 다음 알림에 반응
- 가장 좋은 점은 원본 Observable이 값을 계속 내보내는 한 Flattening Operator는 각 값에 대해 제공된 Observable을 계속 구독
- 예를 제공하기 위해 소스 Observable은 텍스트 값을 내보내는 검색 쿼리 입력일 수 있으며 사용자가 변경할 때마다 
- Flattening Operator는 해당 쿼리와 함께 서버에 요청을 보내고 응답은 출력으로 내보내진다.
-----------------------------

55. Flattening Operators - Static Example

-----------------------------

56. Flattening Operators - Dynamic HTTP Request

-----------------------------

57. Flattening Operators - Error Handling - First Solution

-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------
-----------------------------


58. Flattening Operators - Error Handling - Second Solution
59. Flattening Operators - Concurrency - concatMap
60. Flattening Operators - switchMap
61. Flattening Operators - mergeMap
62. Flattening Operators - Side by Side Comparison
퀴즈 9: Pipeable Operators - Flattening Operators
63. Module Summary
섹션 7: Subjects
64. Module Introduction
65. Multicasting
66. Subject vs Observable vs Observer
67. Subject in Action
68. BehaviorSubject - Concept
69. BehaviorSubject in Action
70. Module Summary
퀴즈 10: Subjects
섹션 8: Course Summary
71. Course Summary
72. Congratulations &amp; Further Steps
